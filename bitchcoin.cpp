#include <iostream>
#include <iomanip>
#include <string>
#include <cstring>
#include <sstream>
#include <fstream>
#include <vector>
#include <memory>
#include <thread>
#include <chrono>
#include <ctime>
#include <cmath>
#include <cstdlib>
#include <openssl/sha.h>
#include "timeutils.hpp"
#include "coinutils.hpp"
#include "./Node.hpp"
#include "./Blockchain.hpp"



#define MAX_TRANSACTION_SIZE 16 //32B
#define REWARD 6.25
#define TOTAL = 21000000 
#define clrscr() std::cout << "\e[1;1H\e[2J"



// global variables
const uint16_t DIFFICULTY = 10;
float TRANSACTION_FEE;
float VALUE;
std::ifstream inputS;
std::ofstream outputS;
std::ofstream logS("./log.txt");
bool finished = 0;

// determined threads to update bitcoin transaction fee and values every 30 seconds
std::thread subSystem1(update, &TRANSACTION_FEE, &VALUE);
std::thread subSystem2(startNodejsProgram);

// judge
std::string whoisthewinner(std::string& correctHash)
{
    std::ifstream infile("./arena");
    std::string line, tmpHash, winner;

    while (std::getline(infile, line) && finished == 0)
    {
        std::istringstream ss(line);
        ss >> tmpHash;

        if (tmpHash == correctHash)
        {
            finished = 1;
            ss >> winner;
        }
    }

    return winner;
}


// IMPORTANT | DEFINE MEMBER FUNCTIONS FROM HEADER

// constructor
Block::Block(std::string& td)
: transactionsData(td)
{
    correctHash = calcHash(transactionsData, DIFFICULTY);
    logS << "Block crated successfully!" << std::endl;
    
}

// destructor
Block::~Block()
{             
    logS << "Block deleted successfully!" << std::endl;
}

//constructor
Blockchain::Blockchain()
{
            
    logS << "Blockchain crated successfully!" << std::endl;

}

//destructor
Blockchain::~Blockchain()
{
    chain.clear();
    logS << "Block deleted successfully!" << std::endl;

}

void Blockchain::openCompetition(std::string& leftOut, std::vector<Node*>& nl)
{
    ++last_index;
    std::unique_ptr<Block> dummyPtr(new Block(tmpTransactionsData));
    chain.push_back(std::move(dummyPtr));
    tmpTransactionsData = ""; //reset tmpTransactionsData
    tmpTransactionsData += leftOut;

    // signal nodes to start competing in order to complete the creation of the newly initialized block
    for (auto& n : nl)
    {
        n->startMining(chain[last_index]->transactionsData);
    }

    std::cout << "All nodes have started mining\nWaiting for the correct hash to be generated" << std::endl;
    std::string winner = whoisthewinner(chain[last_index]->correctHash);
    std::cout << "\nThe correct hash has been generated by node : '" << "' " << winner <<std::endl << "\nWinner will be rewarded with " << REWARD << " bitcoins" << std::endl;
    
    finished = 0;
}

//constructor
Node::Node(std::string& n, int32_t b)
: name(n), balance(b)
{
    logS << "Node created successfully!" << std::endl;
}

// destructor
Node::~Node()
{
    logS << "Node deleted successfully!" << std::endl;
}

void Node::transferTo(Blockchain& blc, std::vector<Node*>& nl, std::string& receiver, uint32_t& amount)
{
    // transfer money
    bool found = 0;
    for (auto& n : nl)
    {
        if (n->name == receiver)
        {
            found = 1;
            n->balance += amount;
            this->balance -= amount;
        }
    }

    // if not found
    if (found == 0) 
    {
        std::cout << "Node doesn't exist!" << std::endl;
        return;
    }

    // write to public ledger
    std::string tmp = this->name + ' ' + receiver + ' ' + std::to_string(amount) + '\n';

    if ( (blc.tmpTransactionsData.length() + tmp.length()) >= MAX_TRANSACTION_SIZE-1 )
    {
        blc.openCompetition(tmp, nl);
    }
    // 
    else
    {
        blc.tmpTransactionsData += tmp;
    }
}

void Node::startMining(std::string& td)
{
    std::ofstream fileout("./arena");
    std::thread worker(guessHash, td, this->name, DIFFICULTY, finished);
    worker.detach();
}


int main()
{
    // pause the main thread for 1s to wait for values to be updated;

    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
    // a vector of NODES(ptr) as a method for the nodes to interact with one another
    std::vector<Node*> nodesList;
    Blockchain chain;
    std::string tmpName;

    for (uint64_t i = 0; i < 10; i++)
    {
        tmpName = "node" + std::to_string(i+1);
        Node* dummyPtr = new Node(tmpName, 100);
        nodesList.push_back(dummyPtr);
    }
    
    Node* whoami = nodesList[0];
    std::cout << "You are now controlling node 1 You can change if you wish to\nPress enter to continue to program...";
    std::cin.get();
    clrscr();

    char option;
    while (1)
    {
        std::cout << "Queries | (t)ransfer, (n)ew node, (s)witch node, (q)uit" << std::endl;
        scanf(" %c", &option);
        switch (option)
        {
            case 'p':
                std::cout << "Print mode selected" << std::endl << "What to print? | (n)ame, (b)alance\n>>> ";
                char option2;
                scanf(" %c", &option2);
                if (option2 == 'n')
                {
                    std::cout << ">>> " << whoami->name << std::endl;
                }

                else if (option2 == 'b')
                {
                    std::cout << "\n>>> " << whoami->balance << std::endl;
                }

                else
                {
                    std::cout << "Inavlid option : " << option2 << std::endl;
                }
                break;

            case 't':
                uint32_t tmpAmount;
                std::cout << "Enter the name of the receiver:\n>>> ";
                std::cin >> tmpName;
                std::cout << "Enter amount of bitcoin to transfer:\n>>> ";
                std::cin >> tmpAmount;
                whoami->transferTo(chain, nodesList, tmpName, tmpAmount);

                //debug
                std::cout << "\nTemporary transaction data : " << chain.tmpTransactionsData << std::endl;
                break;

            case 'n':
                std::cout << "Enter name of new node :\n>>> ";
                std::cin >> tmpName;
                break;

            case 's':
                std::cout << "Enter the name of the node you want to control:\n>>> ";
                std::cin >> tmpName;
                for (auto n : nodesList)
                {
                    if (tmpName == n->name)
                    {
                        whoami = n;
                    } 
                }                
                break;

            case 'q':
                exit(EXIT_SUCCESS);
                break;
            
            case 'c':
                clrscr();
                break;

            default:
                std::cout << "Invalid option : " << option << std::endl;
                break;
        }
    }

    return 0;

}